module Hierclust
  # Clusters a set of Points using Hierarchical Clustering, stopping either
  # when the hierarchy is complete or the clusters are separated by a given
  # minimum distance.
  class Clusterer
    # The Distances for the items being clustered
    attr_reader :distances

    # Create a new Clusterer for the given data.
    #
    # Specify +separation+ to stop the clustering process once all the
    # items are at least +separation+ units apart.
    #
    # Specify +resolution+ to give a minimum size for clusters. Points that
    # are within this distance from each other will not be hierarchically
    # clustered, but will be put into clusters based strictly on coordinates.
    # The clusters generated by this "pre-clustering" will then be
    # hierarchically clustered as normal.
    def initialize(data, separation = nil, resolution = nil)
      @separation = separation
      @resolution = resolution
      @data = precluster(data)
      @distances = Distances.new(@data)
    end

    # Calculates and returns the set of clusters.
    def clusters
      return @data if @separation && @distances.separation > @separation
      while @data.length > 1
        @distances = Distances.new(@data)
        return @data if @separation && @distances.separation > @separation
        @data = find_cluster
      end
      @data
    end

    private

    def find_cluster
      case @data.length
      when 0
        []
      when 1
        [Cluster.new([@data[0]])]
      when 2
        [Cluster.new([@data[0], @data[1]])]
      else
        nearest = @distances.nearest
        outliers = @distances.outliers
        [Cluster.new(nearest), *outliers]
      end
    end

    def precluster(points)
      if @resolution.nil?
        # preclustering is only applicable given lower bound on resolution
        return points.dup
      end
      if @separation.nil?
        # can't precluster w/ no min separation given
        return points.dup
      end
      if @separation == 0
        # if no separation is asked for, it's all one cluster
        return [Cluster.new(points)]
      end
      grid_size = @resolution
      grid_clusters = Hash.new
      points.each do |point|
        index = (0..(point.dimension_count-1)).map {|d| (point.value(d) / grid_size).floor.to_s }.join(",")
        grid_clusters[index] ||= Cluster.new([])
        grid_clusters[index] << point
      end
      grid_clusters.values
    end
  end
end
